<!DOCTYPE html>

<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script type="module">

  // --- FUNCTIONS 
  
  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    for (let key in simulations) {
      if (!event.active) simulations[key].alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
  }
  
  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  
  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    for (let key in simulations) {
      if (!event.active) simulations[key].alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
  }
  
  // Calculate point position in a circle
  function circlePosition(circle, node, index, count) {
    const circunference = circle.node().getTotalLength();
    const sectionLenght = circunference / count;
    const pointPosition = sectionLenght * (count - index);
    return circle.node().getPointAtLength(pointPosition);
  }

  // --- END FUNCTIONS

  
  // Get data from json file using fetch.
  // const data = await fetch("miserables.json").then(response => response.json());
  const data = {
    "nodes": [
      {"id": "M", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "N", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "O", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "P", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "A", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "B", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "C", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "D", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "E", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "F", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "G", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "H", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "I", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "J", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "K", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "L", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "C1", "group": "clubs"},
      {"id": "C2", "group": "clubs"},
      {"id": "C3", "group": "clubs"},
    ],
    "links": [
      {"source": "C1", "target": "B", "value": 6},
      {"source": "C1", "target": "D", "value": 2},
      {"source": "C1", "target": "F", "value": 2},
      {"source": "C1", "target": "N", "value": 1},
      
      {"source": "C2", "target": "A", "value": 1},
      {"source": "C2", "target": "C", "value": 1},
      {"source": "C2", "target": "G", "value": 3},
      {"source": "C2", "target": "H", "value": 3},
      {"source": "C2", "target": "I", "value": 3},
      
      {"source": "C3", "target": "E", "value": 5},
      {"source": "C3", "target": "K", "value": 2},
      {"source": "C3", "target": "M", "value": 7},
      {"source": "C3", "target": "O", "value": 2},
    ],
  };
  
  // Specify the dimensions of the chart.
  const width = 1000;
  const height = 800;

  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);
  
  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const links = data.links.map(d => ({...d}));
  const nodes = data.nodes.map(d => ({...d}));
  
  // Evenly place the nodes of group "national teams" along a circunference
  const nodes_radius = 8;
  const nodes_between = 15; 
  const nodes_teams_count = nodes.filter(d => d.group === "national teams").length;
  const nodes_clubs_count = nodes.length - nodes_teams_count;
  
  // Calculate the diameter of the circunference based on a heuristic distance between nodes.
  const circle_diameter = Math.max(
    (nodes_teams_count * (2.0 * nodes_radius + nodes_between)) / Math.PI, 
    (nodes_clubs_count * (3.0 * nodes_radius)) / Math.PI, 
    200
  );
  const scale = Math.min(width, height) / (circle_diameter + 2*nodes_radius);

  
  // (TODO) simulation force is the one that should be changed to make the nodes to be placed in the right position.
  // to this so hardcoded might dificult the work later, but it it still a good start on the experimentations

  let simulations = {};

  simulations.both = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).strength(d => d.value / 100));
  
  simulations.outer = d3.forceSimulation(nodes.filter(d => d.group === "national teams"))
      .force("collide", d3.forceCollide(2 * nodes_radius + nodes_between * scale))
      .force("radial", d3.forceRadial((circle_diameter * scale)/2, 0, 0).strength(1));
  
  simulations.inner = d3.forceSimulation(nodes.filter(d => d.group === "clubs"))
      .force("collide", d3.forceCollide(nodes_radius + 2))
      .force("x", d3.forceX().x(0).strength(0.05))
      .force("y", d3.forceY().y(0).strength(0.05));
  
  // Create the SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "max-width: 100%; height: auto;");
  
  // Create invisible circle to place the nodes of group "national teams" along a circunference
  const d = circle_diameter * scale;
  const r = d / 2;
  const xMargin = (-width/2) + ((width - d)/2);
  const yMargin = (-height/2) + ((height - d)/2);

  const circle = svg.append("path")
      .attr("d", "M "+xMargin+", "+(r+yMargin)+" a "+r+","+r+" 0 1,0 "+d+",0 a "+r+","+r+" 0 1,0 "+(-1)*d+",0")
      .style("fill", "none");

  nodes.forEach((node, index) => {
    if (node.group === "national teams") {
      const position = circlePosition(circle, node, index, nodes_teams_count);
      node.circleX = position.x;
      node.circleY = position.y;
    }
  });  
  
  // Add a line for each link, and a circle for each node.
  const link = svg.append("g")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.8)
    .selectAll("line")
    .data(links)
    .join("line")
      .attr("stroke-width", d => Math.sqrt(d.value));

  // (TODO) (THINK) some sort heuristics to the national teams nodes. 
  // (TODO) Fix the position of the teams nodes, even with simulation forces (or make forces to their position be stronger).   
  const node = svg.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 0)
    .selectAll("circle")
    .data(nodes)
    .join("circle")
      .attr("r", nodes_radius)
      .attr("fill", d => color(d.group));

  node.append("title").text(d => d.id);

  // Add a drag behavior. 
  node.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
  
  // Set the position attributes of links and nodes each time the simulation ticks.
  for (let key in simulations) {
    simulations[key].on("tick", () => {
      link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
      node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
    });
  }

  
  // When this cell is re-run, stop the previous simulation. (This doesn’t
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but it’s a good practice.)
  // invalidation.then(() => simulation.stop());

  // Append the SVG element.
  container.append(svg.node());

</script>