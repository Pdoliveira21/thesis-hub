<!DOCTYPE html>

<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script type="module">

  // --- FUNCTIONS 
  
  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    for (let key in simulations) {
      if (!event.active) simulations[key].alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
  }
  
  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  
  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    for (let key in simulations) {
      if (!event.active) simulations[key].alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
  }

  function clicked(event, d) {
    // Reset visualization to original style
    node.attr("fill", d => color(d.group)).attr("opacity", d => d.clubs_count === 0 ? 0.3 : 1);
    link.attr("stroke-opacity", 0.8);
    
    // If the node clicked is the one selected, unselect it and return
    if (d.isSelected === true) {
      d.isSelected = false;
      return;
    }
    // Unmark all nodes selection before proceeding
    node.each(n => n.isSelected = false);

    if (d.clubs_count === 0) return;
    
    // Mark the node as selected and unhighlight the elements not its neighboors
    d.isSelected = true;

    let neighboors = links.filter(l => l.source === d || l.target === d).flatMap(l => [l.source, l.target]);
    neighboors = [...new Set(neighboors)];

    node.filter(n => !neighboors.includes(n)).attr("opacity", 0.3);
    link.filter(l => l.source !== d && l.target !== d).attr("stroke-opacity", 0.1);
  }
  
  // Calculate point position in a circle
  function circlePosition(diameter, index, count) {
    let angle = (2 * Math.PI * index) / count - (Math.PI / 2);

    return {
      x: (diameter / 2) * Math.cos(angle),
      y: (diameter / 2) * Math.sin(angle),
    };
  }

  // --- END FUNCTIONS

  
  // nodes start from the upmost point of the circunference and go clockwise
  const data = {
    "nodes": [
      {"id": "A", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "B", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "C", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "D", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "E", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "F", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "G", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "H", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "I", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "J", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "K", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "L", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "M", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "N", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "O", "group": "national teams", "radius": 2, "clubs_count": 1},
      {"id": "P", "group": "national teams", "radius": 2, "clubs_count": 0},
      {"id": "C1", "group": "clubs"},
      {"id": "C2", "group": "clubs"},
      {"id": "C3", "group": "clubs"},
    ],
    "links": [
      {"source": "C1", "target": "B", "value": 6},
      {"source": "C1", "target": "D", "value": 2},
      {"source": "C1", "target": "F", "value": 2},
      {"source": "C1", "target": "N", "value": 1},
      
      {"source": "C2", "target": "A", "value": 1},
      {"source": "C2", "target": "C", "value": 1},
      {"source": "C2", "target": "G", "value": 3},
      {"source": "C2", "target": "H", "value": 3},
      {"source": "C2", "target": "I", "value": 3},
      
      {"source": "C3", "target": "E", "value": 5},
      {"source": "C3", "target": "K", "value": 2},
      {"source": "C3", "target": "M", "value": 7},
      {"source": "C3", "target": "O", "value": 2},
    ],
  };
  
  // Specify the dimensions of the chart.
  const width = 500;
  const height = 500;

  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);
  
  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const links = data.links.map(d => ({...d}));
  const nodes = data.nodes.map(d => ({...d, idSelected: false}));
  
  // Evenly place the nodes of group "national teams" along a circunference
  const nodes_radius = 8;
  const nodes_between = 15; 
  const nodes_teams_count = nodes.filter(d => d.group === "national teams").length;
  const nodes_clubs_count = nodes.length - nodes_teams_count;
  
  // Calculate the diameter of the circunference based on a heuristic distance between nodes.
  const circle_diameter = Math.max(
    (nodes_teams_count * (2.0 * nodes_radius + nodes_between)) / Math.PI, 
    (nodes_clubs_count * (3.0 * nodes_radius)) / Math.PI, 
    200
  );
  const scale = Math.min(width, height) / (circle_diameter + 2 * nodes_radius);

  nodes.forEach((node, index) => {
    if (node.group === "national teams") {
      const position = circlePosition(circle_diameter * scale, index, nodes_teams_count);
      node.circleX = position.x;
      node.circleY = position.y;
    }
  });

  // Define the simulation forces.
  let simulations = {};
  
  simulations.both = d3.forceSimulation(nodes)
    .force("collide", d3.forceCollide(nodes_radius + 2))
    .force("link", d3.forceLink(links).id(d => d.id).strength(d => d.value / 100));
  
  // (NOTE): radial would be agood choice alone if not needed to space evently the nodes and not needed consistency through timelines
  simulations.outer = d3.forceSimulation(nodes.filter(d => d.group === "national teams"))
    .force("radial", d3.forceRadial((circle_diameter * scale)/2, 0, 0).strength(1)) // (THINK) needed?
    .force("x", d3.forceX().x(d => d.circleX).strength(0.7))
    .force("y", d3.forceY().y(d => d.circleY).strength(0.7));
  
  simulations.inner = d3.forceSimulation(nodes.filter(d => d.group === "clubs"))
    .force("x", d3.forceX().x(0).strength(0.01))
    .force("y", d3.forceY().y(0).strength(0.01));
  
  // Create the SVG container.
  const svg = d3.create("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [-width / 2, -height / 2, width, height])
    .attr("style", "max-width: 100%; height: auto;");
  
  // Add a line for each link, and a circle for each node.
  const link = svg.append("g")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.8)
    .selectAll("line")
    .data(links)
    .join("line")
      .attr("stroke-width", d => Math.sqrt(d.value));

  // (TODO) (THINK) some sort heuristics to the national teams nodes. 
  // (TODO) Fix the position of the teams nodes, even with simulation forces (or make forces to their position be stronger).   
  const node = svg.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 0)
    .selectAll("circle")
    .data(nodes)
    .join("circle")
      .attr("r", nodes_radius)
      .attr("fill", d => color(d.group))
      .attr("opacity", d => d.clubs_count === 0 ? 0.3 : 1)
      .on("click", clicked);

  node.append("title").text(d => d.id);

  // Add a drag behavior. 
  // DOUBT: drag or not drag the national teams nodes?
  node.filter(d => d.group === "clubs")
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));
  
  // Set the position attributes of links and nodes each time the simulation ticks.
  for (let key in simulations) {
    simulations[key].on("tick", () => {
      link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
      node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
    });
  }

  
  // When this cell is re-run, stop the previous simulation. (This doesn’t
  // really matter since the target alpha is zero and the simulation will
  // stop naturally, but it’s a good practice.)
  // invalidation.then(() => simulation.stop());

  // Append the SVG element.
  container.append(svg.node());

</script>